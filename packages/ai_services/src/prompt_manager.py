import json
import os
import logging
from typing import Optional, Dict

logger = logging.getLogger(__name__)

DEFAULT_PROMPTS = {
    "classifier": "Ты — системный фильтр сервиса \"Зачёт\". Твоя задача — определить, является ли текст ниже условием конкретной академической задачи (математика, физика, химия, программирование и т.д.).\n\nТЕКСТ ПОЛЬЗОВАТЕЛЯ:\n---\n{input_text}\n---\n\nПРАВИЛА КЛАССИФИКАЦИИ:\n1. Если текст содержит условие задачи, вопрос по конкретному примеру или данные для расчета — это \"task\".\n2. Если текст является общим вопросом (\"расскажи про ИИ\", \"как выучить питон\"), просьбой написать эссе без темы, или просто приветствием — это \"chat\".\n3. Если в тексте только общие слова типа \"помоги\", \"объясни\" без контекста — это \"chat\".\n\nВерни результат в формате JSON: {\"type\": \"task\" | \"chat\", \"reason\": \"краткое пояснение\"}",
    "structure": "Ты — экспертный академический методист. Сформулируй подробный план для работы типа {work_type}.\nТема: {topic}\nЦель: {goal}\nОсновная идея: {idea}\nОбъем: {volume} страниц.\n\nИНСТРУКЦИЯ ПО ФОРМАТУ:\n- Тон изложения: {style}.\n- План должен включать: Введение, Основную часть (главы/параграфы), Заключение, Литература.\n- НИКАКИХ приветствий и лишних рассуждений. Только структура.\n\nВерни результат в формате JSON: {\"structure\": [{\"title\": \"...\", \"level\": 1}]}",
    "sources": "Ты — библиограф в крупной научной библиотеке. Подбери список актуальных источников для следующей работы:\nТип: {work_type}\nТема: {topic}\n\nТРЕБОВАНИЯ:\n1. Минимум 5-7 источников.\n2. Источники должны быть реальными: научные статьи, монографии, учебники, официальные документы.\n3. Обязательно ищи не только статьи в интернете, но и доступные в сети книги и PDF-документы.\n4. Оформи по стандарту ГОСТ Р 7.0.100–2018.\n5. Для каждого источника напиши краткое описание (1-2 предложения), почему он важен для этой темы.\n6. СТРОГО РЕАЛЬНЫЕ URL (прямые ссылки на PDF, страницы в КиберЛенинке, eLibrary или сайты издательств). НИКАКИХ placeholder-ов или example.com.\n\nВерни результат в формате JSON: {\"sources\": [{\"title\": \"...\", \"url\": \"...\", \"description\": \"...\"}]}",
    "generation": "Напиши контент для раздела \"{section_title}\" работы на тему \"{topic}\".\n\nКОНТЕКСТ:\nЦель: {goal}\nИдея: {idea}\n\nТРЕБОВАНИЯ:\n- Академический стиль.\n- Плотный текст без воды.\n{layout_instruction}\n\n{previous_context_instruction}\n\nВерни результат в формате JSON: {\"content\": \"...\", \"layout\": \"...\", \"icons\": [\"...\"], \"visual_meta\": {{...}}, \"image_prompt\": \"...\"}",
    "humanize": "Перепиши следующий академический текст, чтобы он выглядел так, будто его написал человек, а не ИИ.\n\nТЕКСТ ДЛЯ ОБРАБОТКИ:\n---\n{text}\n---\n\nИНСТРУКЦИИ:\n{instructions}\n\nВАЖНО: Сохрани все факты, цифры и научную суть. Изменяй ТОЛЬКО стиль и структуру предложений.",
    "qc": "Ты — строгий академический корректор. Проверь текст на соответствие стандартам ГОСТ и научному стилю.\n\nТЕКСТ ПРОВЕРКИ:\n---\n{text}\n---\n\nЗАДАЧИ:\n1. Проверь отсутствие местоимений \"я\", \"мой\" (замени на \"мы\", \"наш\" или безличные формы).\n2. Убери точки в конце заголовков.\n3. Исправь стилистические ошибки и канцеляризмы.\n4. Проверь логичность переходов между абзацами.\n5. Удали любые фразы-клише ИИ (например, \"в данной главе мы рассмотрели\", \"важно отметить, что\").\n\nВерни ПОЛНОСТЬЮ исправленный текст. Никаких комментариев от себя, только текст работы.",
    "suggest_details": "Ты — академический консультант. На основе темы \"{topic}\" предложи:\n1. Цель работы (1 предложение)\n2. Основную идею (тезис) работы (1-2 предложения)\n\nВерни результат в формате JSON: {\"goal\": \"...\", \"idea\": \"...\"}",
    "suggest_title_info": "Ты — сотрудник отдела кадров университета. По краткому названию вуза \"{university_short}\" найди:\n1. Полное официальное название (например, для МГУ это \"Московский государственный университет имени М.В. Ломоносова\").\n2. Город, в котором находится главный корпус.\n\nВерни результат в формате JSON: {\"university_full\": \"...\", \"city\": \"...\"}"
}

class PromptManager:
    def __init__(self, config_path: Optional[str] = None):
        self.config_path = config_path
        self.prompts = self._load_config()

    def _load_config(self):
        if self.config_path and os.path.exists(self.config_path):
            try:
                with open(self.config_path, "r", encoding="utf-8") as f:
                    return json.load(f)
            except Exception as e:
                logger.error(f"Failed to load prompts config: {e}")
        return DEFAULT_PROMPTS

    def save_config(self, new_config: dict):
        if not self.config_path:
            logger.error("Cannot save config: no config_path set")
            return False
        try:
            with open(self.config_path, "w", encoding="utf-8") as f:
                json.dump(new_config, f, indent=2, ensure_ascii=False)
            self.prompts = new_config
            return True
        except Exception as e:
            logger.error(f"Failed to save prompts config: {e}")
            return False

    def get_prompt(self, name: str) -> str:
        return self.prompts.get(name, DEFAULT_PROMPTS.get(name, ""))

prompt_manager = PromptManager(os.path.join(os.path.dirname(__file__), "../../../apps/api/data/prompts.json"))
